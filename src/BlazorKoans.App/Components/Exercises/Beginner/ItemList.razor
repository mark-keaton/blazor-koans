@* â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘  ğŸ” OBSERVE                                                              â•‘
   â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
   â•‘  This is a GENERIC templated component - notice @typeparam TItem.        â•‘
   â•‘  It can render a list of ANYTHING: strings, numbers, objects, etc.       â•‘
   â•‘                                                                          â•‘
   â•‘  Key differences from Card's RenderFragment:                             â•‘
   â•‘  â€¢ RenderFragment      = just UI content (no data)                       â•‘
   â•‘  â€¢ RenderFragment<T>   = UI template that RECEIVES data of type T        â•‘
   â•‘                                                                          â•‘
   â•‘  Usage:                                                                  â•‘
   â•‘  <ItemList Items="@fruits">                                              â•‘
   â•‘      <ItemTemplate>                                                      â•‘
   â•‘          <li>@context</li>     â† "context" is each TItem in the loop     â•‘
   â•‘      </ItemTemplate>                                                     â•‘
   â•‘  </ItemList>                                                             â•‘
   â•‘                                                                          â•‘
   â•‘  ğŸ§ª EXPERIMENT                                                           â•‘
   â•‘  â€¢ Change <ul> to <ol> - what changes in the output?                     â•‘
   â•‘  â€¢ What happens if Items is empty? Does the <ul> still render?           â•‘
   â•‘  â€¢ Why is ItemTemplate?.Invoke() used instead of just @ItemTemplate?     â•‘
   â•‘                                                                          â•‘
   â•‘  ğŸ’¡ THINK: How does the parent's <ItemTemplate> content know about each  â•‘
   â•‘            item? What is "context" and where does it come from?          â•‘
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *@

@* âš¡ TRY: What if you remove the @typeparam below? *@
@typeparam TItem

<ul>
    @foreach (var item in Items)
    {
        @ItemTemplate?.Invoke(item)                 @* The "item" becomes "context" in parent *@
    }
</ul>

@code {
    [Parameter]
    public IEnumerable<TItem> Items { get; set; } = Array.Empty<TItem>();

    [Parameter]
    public RenderFragment<TItem>? ItemTemplate { get; set; }    // âš¡ Compare to Card's RenderFragment
}

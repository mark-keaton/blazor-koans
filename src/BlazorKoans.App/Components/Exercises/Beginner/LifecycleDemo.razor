@* â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   â•‘  ğŸ” OBSERVE                                                              â•‘
   â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
   â•‘  This component demonstrates the Blazor LIFECYCLE - methods called at    â•‘
   â•‘  specific times during a component's life:                               â•‘
   â•‘                                                                          â•‘
   â•‘  1. OnInitialized      â†’ Called ONCE when component first created        â•‘
   â•‘  2. OnParametersSet    â†’ Called when parameters change (including init)  â•‘
   â•‘  3. OnAfterRender      â†’ Called AFTER the DOM is updated                 â•‘
   â•‘  4. Dispose            â†’ Called when component is removed                â•‘
   â•‘                                                                          â•‘
   â•‘  Notice the DisposalTracker service - it tracks registered components.   â•‘
   â•‘  A properly disposed component should UNREGISTER itself.                 â•‘
   â•‘                                                                          â•‘
   â•‘  âš ï¸  IMPORTANT: This component has a bug! It has Dispose() but Blazor    â•‘
   â•‘      won't call it because @implements IDisposable is MISSING!           â•‘
   â•‘                                                                          â•‘
   â•‘  ğŸ§ª EXPERIMENT                                                           â•‘
   â•‘  â€¢ What status message appears when the component loads?                 â•‘
   â•‘  â€¢ Pass Value="blazor" - what does formattedValue become?                â•‘
   â•‘  â€¢ Run the E_DisposeIsCalled test - does it pass? Why not?               â•‘
   â•‘  â€¢ Add @implements IDisposable after @inject - what changes?             â•‘
   â•‘                                                                          â•‘
   â•‘  ğŸ’¡ THINK: Why would Dispose() exist but never be called? What does      â•‘
   â•‘            @implements IDisposable actually DO?                          â•‘
   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• *@

@using BlazorKoans.App.Services
@inject DisposalTracker Tracker
@* âš¡ TODO: Add "@implements IDisposable" here to fix the bug! *@

<div>
    <p class="status">@status</p>
    <p class="render-count">Renders: @renderCount</p>
    <p class="param-value">@formattedValue</p>
</div>

@code {
    [Parameter]
    public string Value { get; set; } = string.Empty;

    private string status = string.Empty;
    private string formattedValue = string.Empty;
    private int renderCount = 0;

    protected override void OnInitialized()                     // âš¡ Called ONCE on startup
    {
        status = "Initialized";
        Tracker.Register(this);
    }

    protected override void OnParametersSet()                   // âš¡ Called when params change
    {
        // Compute derived state from parameter
        formattedValue = string.IsNullOrEmpty(Value)
            ? "No value set"
            : $"Received: {Value.ToUpper()}";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)  // âš¡ Called AFTER DOM update
    {
        if (firstRender)
        {
            renderCount = 1;
            await InvokeAsync(StateHasChanged);
        }
        else
        {
            renderCount++;
        }
    }

    public void Dispose()                                       // âš¡ Called on removal (IF @implements!)
    {
        Tracker.Unregister(this);
    }
}
